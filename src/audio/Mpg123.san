package audio;

class Mpg123 {
    c__include "mpg123.h";
    c__repr    "mpg123_handle*";

const FLOAT_32_ENCODING = 0;

const CBR = 0;
const VBR = 1;
const ABR = 2;

const NEW_FORMAT = -11;
const DONE = -12;

/**
 * Perform necessary one-time setup tasks for the mpg123 library's internal state.
 */
static void init() {
    c__stmt "mpg123_init()";
}

Mpg123() {
    var err = 0;
    c__stmt "mpg123_handle *t = mpg123_new(NULL, &err)";
    if err != 0 {
        System.println("mpg123_new failed error " + err);
    }
    c__stmt "return t";
}

/**
 * Open mp3 file.
 */
int open(String filename) {
    c__stmt "int status = mpg123_open(this, filename)";
    c__stmt "mpg123_param(this, MPG123_ADD_FLAGS, MPG123_FORCE_FLOAT, 0.)";
    c__stmt "return status";
}

/**
 * Get the mp3 file's rate, channels, and encoding.
 */
MpgFormat get_format() {
    var f = new MpgFormat();
    c__stmt "mpg123_getformat(this, &f->rate, &f->channels, &f->encoding)";
    return f;
}

/**
 * Clear all default format settings before using set_format to set your custom list.
 */
int format_none() {
    c__stmt "return mpg123_format_none(this)";
}

/**
 * Set the allowed output audio formats. This does not change the format on the fly.
 * It configures an internal table of supported formats. When libmpg123 encounters a
 * new frame or a change in the stream's properties, it consults this table to
 * determine the most suitable output format.
 *
 * @rate      sample rate specified in hertz
 * @channels  bitwise OR of MONO (1) and STEREO (2)
 */
int set_format(long rate, int channels, boolean use_float32) {
    c__stmt "int encoding = use_float32 ? MPG123_ENC_FLOAT_32 : MPG123_ENC_SIGNED_16";
    c__stmt "return mpg123_format(this, rate, channels, encoding)";
}

boolean is_encoding_float32() {
    c__stmt "long rate";
    c__stmt "int channels, encoding";
    c__stmt "mpg123_getformat2(this, &rate, &channels, &encoding, 0)";
    c__stmt "return encoding & MPG123_ENC_FLOAT_32";
}

/**
 * Read data and decode the raw PCM samples.
 *
 * @return bytes read
 */
int read(byte[] buffer) {
    var err = 0;
    c__stmt "size_t read";
    c__stmt "err = mpg123_read(this, buffer->data, buffer->length, &read)";
    if err != 0 {
        return 0;
    }
    c__stmt "return (int) read";
}

/**
 * Seek forwards or backwards in the stream.
 * The get_format rate is the number of samples per second.
 */
long seek(long samples) {
    c__stmt "return mpg123_seek(this, samples, SEEK_SET)";
}

/**
 * @return the number of samples in the mp3 file
 */
 long length() {
     c__stmt "return mpg123_length(this)";
 }

/**
 * Return the string description of this object's last error.
 */
String strerror() {
    c__stmt "return mpg123_strerror(this)";
}

/**
 * Close mp3 file.
 */
void close() {
    c__stmt "mpg123_close(this)";
}

/**
 * Destroy this mpg123 reader.
 */
void delete() {
    c__stmt "mpg123_delete(this)";
}

static void exit() {
    c__stmt "mpg123_exit()";
}

int scan() {
    c__stmt "return mpg123_scan(this)";
}

int framebyframe_next() {
    c__stmt "return mpg123_framebyframe_next(this)";
}

long tell() {
    c__stmt "return mpg123_tell(this)";
}

boolean info(FrameInfo fi) {
    c__stmt "struct mpg123_frameinfo info";
    c__stmt "if (mpg123_info(this, &info) != MPG123_OK) return 0";
    c__stmt "fi->vbr = info.vbr";
    c__stmt "fi->bitrate = info.bitrate";
    c__stmt "fi->abr_rate = info.abr_rate";
    return true;
}

Id3Info id3() {
    c__stmt "mpg123_id3v1 *v1";
    c__stmt "mpg123_id3v2 *v2";
    c__stmt "if (mpg123_id3(this, &v1, &v2) != MPG123_OK) return NULL";

    var id3 = new Id3Info();
    var v1tag = "ID3v1";
    var v11tag = "ID3v11";
    c__stmt "if (v1 != NULL) { id3->version = v1tag";
    c__stmt "id3->title = _id3_string(v1->title, 30)";
    c__stmt "id3->artist = _id3_string(v1->artist, 30)";
    c__stmt "id3->album = _id3_string(v1->album, 30)";
    c__stmt "id3->year = _id3_string(v1->year, 4)";
    c__stmt "id3->comment = _id3_string(v1->comment, 30)";
    c__stmt "if (v1->comment[28] == 0 && v1->comment[29] != 0) { id3->version = v11tag";
    c__stmt "id3->track_number = v1->comment[29]; }}";

    var v2version = 0;
    c__stmt "if (v2 != NULL && v2->version > 0) { v2version = v2->version";
    c__stmt "id3->title = _id3v2_string(v2->title)";
    c__stmt "id3->artist = _id3v2_string(v2->artist)";
    c__stmt "id3->album = _id3v2_string(v2->album)";
    c__stmt "id3->year = _id3v2_string(v2->year)";
    c__stmt "id3->genre = _id3v2_string(v2->genre)";
    c__stmt "id3->comment = _id3v2_string(v2->comment)";
    var trck = "TRCK";
    var tpe2 = "TPE2";
    var tdrc = "TDRC";
    c__stmt "for (int i = 0; i < v2->texts; i++) { mpg123_text *frame = &v2->text[i]";
    c__stmt "if (strncmp(frame->id, trck, 4) == 0) id3->track_number = atoi(frame->text.p)";
    c__stmt "if (strncmp(frame->id, tpe2, 4) == 0) id3->album_artist = _id3v2_string(&frame->text)";
    c__stmt "if (strncmp(frame->id, tdrc, 4) == 0) id3->record_date = _id3v2_string(&frame->text)";
    c__stmt "}}";
    if v2version > 0 {
        id3.version = "ID3v2" + v2version;
    }
    return id3;
}

c__stmt "char *_id3_string(const char *src, int len) {";
c__stmt "if (src[0] == 0) return NULL;";
c__stmt "char *ret = GC_MALLOC_ATOMIC(len+1); strncpy(ret, src, len); ret[len] = 0; return ret; }";

c__stmt "char *_id3v2_string(mpg123_string *src) {";
c__stmt "return (src == NULL || src->p == NULL || src->p[0] == 0) ? NULL : STRING_SUBSTRING(src->p, 0, 0, 1); }";

/**
 * Open an MP3 file and return a read-only byte-array with its first id3v2 picture.
 * The returned array is only valid until the file is closed. The file must be closed.
 */
byte[] open_id3v2_picture(String filename) {
    c__stmt "if (mpg123_param(this, MPG123_FLAGS, MPG123_PICTURE, 0) != MPG123_OK) return NULL";
    c__stmt "if (mpg123_open(this, filename) != MPG123_OK) return NULL";
    c__stmt "mpg123_id3v1 *v1";
    c__stmt "mpg123_id3v2 *v2";
    c__stmt "if (mpg123_scan(this) != MPG123_OK) return NULL";
    c__stmt "if (mpg123_id3(this, &v1, &v2) != MPG123_OK) return NULL";
    c__stmt "if (v2 == NULL || v2->pictures == 0) return NULL";
    c__stmt "mpg123_picture *pic = &v2->picture[0]";
    var ret = new byte[];
    c__stmt "ret->data = pic->data";
    c__stmt "ret->length = pic->size";
    c__stmt "ret->alloced = 0";
    return ret;
}
}
