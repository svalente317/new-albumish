/*
 *  Copyright (c) 2014  Salvatore Valente <svalente@mit.edu>
 *
 *  This program is free software.  You can modify and distribute it under
 *  the terms of the GNU General Public License.  There is no warranty.
 *  See the file "COPYING" for more information.
 */
package albumish;
import gdk.CairoType;
import gtk.DrawingArea;
import gtk.Widget;

class Slider {
    const CHANNEL_HEIGHT = 4;
    const SLIDER_HEIGHT = 24;
    const SLIDER_WIDTH = 30;

    private DrawingArea area;
    private int selection;
    private int maximum;
    private int slider_x;
    private int slider_y;
    private boolean is_grabbed;
    private int grab_offset;

    Slider() {
        // super(parent, SWT.DOUBLE_BUFFERED);
        this.area = new DrawingArea();
        this.area.setSizeRequest(SLIDER_WIDTH+2, SLIDER_HEIGHT+2);
        this.area.setExpand(true, false);
        this.area.connect("draw", this);
    }

    Widget widget() {
        return this.area;
    }

    void callback(DrawingArea area, CairoType cairo) {
        var width = area.getAllocatedWidth()-2;
        var height = area.getAllocatedHeight()-2;
        if height < CHANNEL_HEIGHT {
            return;
        }
        var context = area.getStyleContext();
        var state = context.getState();
        var color = context.getColor(state);
        cairo.setSourceRGBA(color);
        cairo.setLineWidth(1);
        var y = (height - CHANNEL_HEIGHT) / 2;
        cairo.rectangle(1, 1+y, width, CHANNEL_HEIGHT);
        cairo.stroke();
        if this.maximum == 0 {
            return;
        }

        var channelWidth = width - SLIDER_WIDTH;
        var ratio = (double) channelWidth / (double) this.maximum;
        this.slider_x = 1 + (int) (ratio * this.selection);
        y = (height - SLIDER_HEIGHT) / 2;
        this.slider_y = 1 + y;

        var fillColor = context.lookupColor("theme_selected_bg_color");
        if fillColor != null {
            cairo.setSourceRGBA(fillColor);
            cairo.rectangle(this.slider_x, this.slider_y, SLIDER_WIDTH, SLIDER_HEIGHT);
            cairo.fill();
            cairo.setSourceRGBA(color);
        }
        cairo.rectangle(this.slider_x, this.slider_y, SLIDER_WIDTH, SLIDER_HEIGHT);
        cairo.stroke();
    }

    /*
    @Override
    public void mouseDown(MouseEvent event) {
        if (this.maximum == 0) {
            return;
        }
        if (event.x < this.slider_x || event.x > this.slider_x + SLIDER_WIDTH) {
            return;
        }
        if (event.y < this.slider_y || event.y > this.slider_y + SLIDER_HEIGHT) {
            return;
        }
        this.is_grabbed = true;
        this.grab_offset = event.x - this.slider_x;
    }

    @Override
    public void mouseUp(MouseEvent mouseEvent) {
        if (!this.is_grabbed) {
            return;
        }
        this.is_grabbed = false;
        Event event = new Event();
        event.stateMask = mouseEvent.stateMask;
        event.time = mouseEvent.time;
        event.x = mouseEvent.x;
        event.y = mouseEvent.y;
        event.detail = this.selection;
        notifyListeners(SWT.Selection, event);
    }

    @Override
    public void mouseMove(MouseEvent event) {
        if (!this.is_grabbed) {
            return;
        }
        Point size = getSize();
        int channel_width = size.x - SLIDER_WIDTH;
        double ratio = (double) this.maximum / (double) channel_width;
        int new_selection = (int) (ratio * (event.x - this.grab_offset));
        if (new_selection < 0) {
            new_selection = 0;
        }
        if (new_selection > this.maximum) {
            new_selection = this.maximum;
        }
        if (new_selection != this.selection) {
            this.selection = new_selection;
            redraw();
        }
    }
    */

    void setMaximum(int value) {
        this.maximum = value;
        // TODO redraw();
    }

    void setSelection(int value) {
        if !this.is_grabbed {
            this.selection = value;
            // TODO redraw();
        }
    }
}
