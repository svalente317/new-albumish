/*
 *  Copyright (c) 2014  Salvatore Valente <svalente@mit.edu>
 *
 *  This program is free software.  You can modify and distribute it under
 *  the terms of the GNU General Public License.  There is no warranty.
 *  See the file "COPYING" for more information.
 */
package albumish;
import gdk.CairoType;
import gtk.DrawingArea;
import gtk.Widget;

class Slider {
    const CHANNEL_HEIGHT = 4;
    const SLIDER_HEIGHT = 24;
    const SLIDER_WIDTH = 30;

    private SliderListener listener;
    private DrawingArea area;
    private int selection;
    private int maximum;
    private int slider_x;
    private int slider_y;
    private boolean is_grabbed;
    private int grab_offset;

    Slider(SliderListener listener) {
        // super(parent, SWT.DOUBLE_BUFFERED);
        this.listener = listener;
        this.area = new DrawingArea();
        this.area.setSizeRequest(SLIDER_WIDTH+2, SLIDER_HEIGHT+2);
        this.area.setExpand(true, false);
        this.area.connectDraw(this);
        this.area.connectMouseButton(this);
        this.area.connectMouseMotion(this);
    }

    Widget widget() {
        return this.area;
    }

    void draw(DrawingArea area, CairoType cairo) {
        var width = area.getAllocatedWidth()-2;
        var height = area.getAllocatedHeight()-2;
        if height < CHANNEL_HEIGHT {
            return;
        }
        var context = area.getStyleContext();
        var state = context.getState();
        var color = context.getColor(state);
        cairo.setSourceRGBA(color);
        cairo.setLineWidth(1);
        var y = (height - CHANNEL_HEIGHT) / 2;
        cairo.rectangle(1, 1+y, width, CHANNEL_HEIGHT);
        cairo.stroke();
        if this.maximum == 0 {
            return;
        }

        var channelWidth = width - SLIDER_WIDTH;
        var ratio = (double) channelWidth / (double) this.maximum;
        this.slider_x = 1 + (int) (ratio * this.selection);
        y = (height - SLIDER_HEIGHT) / 2;
        this.slider_y = 1 + y;

        var fillColor = context.lookupColor("theme_selected_bg_color");
        if fillColor != null {
            cairo.setSourceRGBA(fillColor);
            cairo.rectangle(this.slider_x, this.slider_y, SLIDER_WIDTH, SLIDER_HEIGHT);
            cairo.fill();
            cairo.setSourceRGBA(color);
        }
        cairo.rectangle(this.slider_x, this.slider_y, SLIDER_WIDTH, SLIDER_HEIGHT);
        cairo.stroke();
    }

    boolean callback(Widget w, int eventType, double x, double y, int button) {
        switch eventType {
        case Widget.BUTTON_PRESS:
            if this.maximum == 0 {
                break;
            }
            if x < this.slider_x || x > this.slider_x + SLIDER_WIDTH {
                break;
            }
            if y < this.slider_y || y > this.slider_y + SLIDER_HEIGHT {
                break;
            }
            this.is_grabbed = true;
            this.grab_offset = (int)(x - this.slider_x);
            break;
        case Widget.BUTTON_RELEASE:
            if !this.is_grabbed {
                break;
            }
            this.is_grabbed = false;
            this.listener.select(this.selection);
            break;
        case Widget.MOTION_NOTIFY:
            if !this.is_grabbed {
                break;
            }
            var width = this.area.getAllocatedWidth()-2;
            var channelWidth = width - SLIDER_WIDTH;
            var ratio = (double) this.maximum / (double) channelWidth;
            var new_selection = (int) (ratio * (x - this.grab_offset));
            if new_selection < 0 {
                new_selection = 0;
            }
            if new_selection > this.maximum {
                new_selection = this.maximum;
            }
            if new_selection != this.selection {
                this.selection = new_selection;
                redraw();
            }
            break;
        }
        return false;
    }

    void setMaximum(int value) {
        this.maximum = value;
        redraw();
    }

    void setSelection(int value) {
        if !this.is_grabbed {
            this.selection = value;
            redraw();
        }
    }

    void redraw() {
        this.area.queueDraw();
    }
}

interface SliderListener {
    void select(int value);
}
