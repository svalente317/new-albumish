/*
 *  Copyright (c) 2014  Salvatore Valente <svalente@mit.edu>
 *
 *  This program is free software.  You can modify and distribute it under
 *  the terms of the GNU General Public License.  There is no warranty.
 *  See the file "COPYING" for more information.
 */
package albumish;
import sanka.io.File;
import sanka.lang.IntChannel;
import sanka.lang.Thread;
import audio.Mpg123;
import gdk.Pixbuf;
import gtk.Context;
import albumish.database.Album;
import albumish.database.Artist;

class Gallery {
    const CHANNEL_SIZE = 12;

    private Albumish player;
    private File topdir;
    private int small_size;
    private int big_size;
    private boolean[] is_loaded;
    private map[int]Pixbuf small_map;
    private map[int]Pixbuf big_map;
    private IntChannel channel;
    private Thread thread;

    Gallery(Albumish player, File topdir, int small_size, int big_size) {
        this.player = player;
        this.topdir = topdir;
        this.small_size = small_size;
        this.big_size = big_size;
        this.is_loaded = new boolean[](player.database.album_list.length);
        this.small_map = new map[int]Pixbuf;
        this.big_map = new map[int]Pixbuf;
        this.channel = new IntChannel(CHANNEL_SIZE);
        this.thread = new Thread(this);
    }

    void get_sizes(int[] sizes) {
        sizes[0] = this.small_size;
        sizes[1] = this.big_size;
    }

    Pixbuf get(int albumid, boolean is_selected) {
        if this.is_loaded.length <= albumid {
            this.is_loaded.setLength(albumid+1);
        }
        if !this.is_loaded[albumid] {
            while this.channel.getQueueSize() >= CHANNEL_SIZE {
                this.channel.pop();
            }
            this.channel.push(albumid);
            return null;
        }
        return is_selected ? this.big_map[albumid] : this.small_map[albumid];
    }

    void run() {
        while true {
            var albumid = this.channel.pop();
            if !this.is_loaded[albumid] {
                this.is_loaded[albumid] = true;
                load_image(albumid);
            }
        }
    }

    private void load_image(int albumid) {
        var image = null;
        var album = this.player.database.album_list[albumid];
        var file = get_image_file(album);
        if file != null {
            image = Pixbuf.new_from_file(file.getPath());
        }
        if image == null {
            image = get_audio_file_artwork(album.song_list[0]);
        }
        if image == null {
            return;
        }
        var small_image = image.scale_simple(this.small_size, this.small_size,
            Pixbuf.INTERP_BILINEAR);
        var big_image = image.scale_simple(this.big_size, this.big_size,
            Pixbuf.INTERP_BILINEAR);
        image.unref();
        this.small_map[albumid] = small_image;
        this.big_map[albumid] = big_image;

        Context.default_context().invoke(new {
            player: this.player;
            albumid: albumid;
            void callback() {
                this.player.invalidate_album(this.albumid);
            }
        });
    }

    File get_image_file(Album album) {
        if album.name == null {
            return null;
        }
        var artistid = album.artistid;
        if artistid <= 0 {
            return null;
        }
        var artist_name = this.player.database.artist_list[artistid].name;
        if artist_name == null {
            return null;
        }
        var filename = Utils.name_to_filename(artist_name) + " - " +
            Utils.name_to_filename(album.name) + ".jpg";
        return new File(this.topdir, filename);
    }

    private Pixbuf get_audio_file_artwork(int songid) {
        var song = this.player.database.song_list[songid];
        var filename = this.player.get_file(song).getPath();
        var mpg = new Mpg123();
        var data = mpg.open_id3v2_picture(filename);
        var image = data != null ? Pixbuf.new_from_bytes(data) : null;
        System.println(song.filename + ": " + (image != null));
        mpg.close();
        mpg.delete();
        return image;
    }

    // removed: audio_file_has_artwork, copy_file, invalidate
}
