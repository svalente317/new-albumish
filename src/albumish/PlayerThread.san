/*
 *  Copyright (c) 2014  Salvatore Valente <svalente@mit.edu>
 *
 *  This program is free software.  You can modify and distribute it under
 *  the terms of the GNU General Public License.  There is no warranty.
 *  See the file "COPYING" for more information.
 */
package albumish;
import sanka.lang.Channel;
import sanka.lang.Thread;
import audio.Mpg123;
import audio.MiniAudio;
import gtk.Context;
import albumish.database.Song;

class PlayerThread {
    const UPDATE_MILLIS = 250;

    private Albumish player;
    private Channel channel;
    private int playlistid;
    private int songid;
    private Thread thread;
    private PlayerCommand command;
    private Mpg123 mpg;
    private MiniAudio audio;
    private int samples_per_second;
    private int audio_position;
    private int updated_audio_position;
    boolean is_paused;

    PlayerThread(Albumish player) {
        Mpg123.init();
        this.player = player;
        this.channel = new Channel(10);
        this.thread = new Thread(this);
    }

    void run() {
        while true {
            var command = (PlayerCommand) this.channel.pop();
            if command.tag == PlayerCommand.PAUSE {
                if this.audio != null {
                    this.audio.stop();
                    update_display(false);
                    this.is_paused = true;
                }
                continue;
            }
            if command.tag == PlayerCommand.UNPAUSE {
                if this.audio != null && this.is_paused {
                    this.is_paused = false;
                    this.audio.play();
                }
                continue;
            }
            if command.tag == PlayerCommand.JUMP {
                if this.mpg != null {
                    if !this.is_paused {
                        this.audio.stop();
                    }
                    var seconds = (double) command.target_ms / 1000;
                    if this.mpg.seek((long)(seconds * this.samples_per_second)) >= 0 {
                        this.audio_position = command.target_ms;
                    }
                    update_display(false);
                    if !this.is_paused {
                        this.audio.play();
                    }
                }
                continue;
            }
            if command.tag == PlayerCommand.PLAY {
                stop();
                this.playlistid = command.playlistid;
                this.songid = command.songid;
                if this.songid <= 0 {
                    update_display(true);
                    command = null;
                    continue;
                }
                var song = this.player.database.song_list[this.songid];
                open_file(song);
                this.is_paused = false;
                this.audio.play();
                continue;
            }
        }
    }

    private void open_file(Song song) {
        var mpg = new Mpg123();
        var err = mpg.open(System.getenv("HOME") + "/" + song.filename);
        if err != 0 {
            System.println("open: " + err);
            return;
        }
        // Get this file's default rate and channels.
        var fmt = mpg.get_format();

        // Tell mpg123 to encode samples as 32-bit floats.
        err = mpg.format_none();
        if err != 0 {
            System.println("format_none: " + err);
        }
        err = mpg.set_format(fmt.rate, fmt.channels, true);
        if err != 0 {
            System.println("set_format: " + err);
        }
        var use_float32 = mpg.is_encoding_float32();

        // Setup for play_file().
        this.mpg = mpg;
        this.audio_position = 0;
        this.samples_per_second = (int) fmt.rate;
        this.audio = new MiniAudio(fmt.rate, fmt.channels, use_float32, this);

        update_display(true);
    }

    /**
     * Miniaudio callback to fill the audio buffer.
     */
    void audio_callback(MiniAudio audio, byte[] output, int frame_count) {
        var size = this.mpg.read(output);
        if size < output.length {
            System.println("done @ " + System.currentTimeMillis());
            play_next_song(1);
        }
        var seconds = ((double) frame_count) / this.samples_per_second;
        var millis = (int)(seconds * 1000);
        this.audio_position = this.audio_position + millis;
        if this.audio_position < this.updated_audio_position ||
            this.audio_position > this.updated_audio_position + UPDATE_MILLIS {
            update_display(false);
        }
    }

    private void stop() {
        if this.audio != null {
            this.audio.uninit();
            this.audio = null;
        }
        if this.mpg != null {
            this.mpg.close();
            this.mpg.delete();
            this.mpg = null;
        }
    }

    /**
     * This is called by the audio thread when it starts playing a new song, and
     * when it reaches the end of the playlist.
     */
    private void update_display(boolean newSong) {
        Context.default_context().invoke(new {
            player_thread: this;
            newSong: newSong;
            void callback() {
                this.player_thread.update_display_in_main_thread(this.newSong);
            }
        });
    }

    void update_display_in_main_thread(boolean newSong) {
        if newSong {
            var song = this.player.database.song_list[this.songid];
            this.player.update_top_panel(song);
            this.player.jump_to_playing_song(false);
        } else {
            this.player.display_time(this.audio_position);
            this.updated_audio_position = this.audio_position;
        }
    }

    /**
     * This is called by the GUI thread to start playing a specific song.
     */
    void play_songid(int playlistid, int songid) {
        this.channel.push(new PlayerCommand(){
            tag: PlayerCommand.PLAY, playlistid: playlistid, songid: songid
        });
    }

    /**
     * This is called by the GUI thread to start playing the previous or next song in
     * the playlist.
     */
    void play_next_song(int delta) {
        var playlist = this.player.playlists[this.playlistid];
        var songid = playlist == null ? 0 : playlist.get_next_id(this.songid, delta);
        this.channel.push(new PlayerCommand(){
            tag: PlayerCommand.PLAY, playlistid: this.playlistid, songid: songid
        });
    }

    /**
     * This is called by the GUI thread to pause and unpause the player.
     *
     * @return true if the player is now paused
     */
    boolean pause(boolean do_pause) {
        var tag = do_pause ? PlayerCommand.PAUSE : PlayerCommand.UNPAUSE;
        this.channel.push(new PlayerCommand(){tag: tag});
    }

    /**
     * Tell the player to jump forwards or backwards in the audio stream.
     */
    void do_audio_jump(int target_ms) {
        this.channel.push(new PlayerCommand(){tag: PlayerCommand.JUMP, target_ms: target_ms});
    }

    boolean is_playing() {
        return this.mpg != null;
    }

    /**
     * @return the length of the audio stream that has been played.
     */
    int get_audio_position_in_ms() {
        return this.audio_position;
    }

    int get_playing_listid() {
        return this.playlistid;
    }

    int get_playing_songid() {
        return this.songid;
    }
}
