/*
 *  Copyright (c) 2014  Salvatore Valente <svalente@mit.edu>
 *
 *  This program is free software.  You can modify and distribute it under
 *  the terms of the GNU General Public License.  There is no warranty.
 *  See the file "COPYING" for more information.
 */
package albumish;
import sanka.lang.Channel;
import sanka.lang.Thread;
import audio.Mpg123;
import audio.PulseAudio;
import gtk.Context;
import albumish.database.Song;

class PlayerThread {
    const SAMPLE_MILLIS = 250;

    private Albumish player;
    private Channel channel;
    private int playlistid;
    private int songid;
    private Thread thread;
    private PlayerCommand command;
    private Mpg123 mpg;
    private PulseAudio pulse;
    private int bufferSize;
    private float audio_position;
    boolean is_paused;

    PlayerThread(Albumish player) {
        Mpg123.init();
        this.player = player;
        this.channel = new Channel(10);
        this.thread = new Thread(this);
    }

    void run() {
        var command = null;
        while true {
            if command == null {
                command = (PlayerCommand) this.channel.pop();
            }
            if command.tag == PlayerCommand.PAUSE {
                System.println("pause");
                this.is_paused = true;
                command = null;
                continue;
            }
            if this.is_paused {
                System.println("unpause");
                this.is_paused = false;
            }
            if command.tag == PlayerCommand.PLAY {
                stop();
                this.playlistid = command.playlistid;
                this.songid = command.songid;
                if this.songid <= 0 {
                    update_display();
                    command = null;
                    continue;
                }
                var song = this.player.database.song_list[this.songid];
                open_file(song);
            }
            var complete = play_file();
            if !complete {
                command = null;
                continue;
            }
            command.tag = PlayerCommand.PLAY;
            command.playlistid = this.playlistid;
            var playlist = this.player.playlists[this.playlistid];
            command.songid = playlist == null ? 0 : playlist.get_next_id(this.songid, 1);
        }
    }

    private void open_file(Song song) {
        var mpg = new Mpg123();
        var err = mpg.open(System.getenv("HOME") + "/" + song.filename);
        if err != 0 {
            System.println("open: " + err);
            return;
        }
        // Get this file's default rate and channels.
        var fmt = mpg.getFormat();

        // Tell mpg123 to encode samples in signed 16-bit format.
        err = mpg.formatNone();
        if err != 0 {
            System.println("formatNone: " + err);
            return;
        }
        err = mpg.setFormat(fmt.rate, fmt.channels, Mpg123.SIGNED_16_ENCODING);
        if err != 0 {
            System.println("formatNone: " + err);
            return;
        }

        // The number of bytes in a 16-bit sample is 2 bytes (16 bits) * the channels.
        var sampleSize = 2 * fmt.channels;
        // fmt.rate is the number of samples per second, typically 44,100.
        var bytesPerSecond = fmt.rate * sampleSize;
        // Read 250 milliseconds at a time.
        var bufferSize = (int)(bytesPerSecond * SAMPLE_MILLIS / 1000);

        // Technically, we should select SIGNED_16_LE_FORMAT or SIGNED_16_BE_FORMAT,
        // depending on the host's endian-ness. But it's fair to assume LE.
        var pulse = new PulseAudio("mp3play", "playback",
            fmt.rate, fmt.channels, PulseAudio.SIGNED_16_LE_FORMAT);

        // Setup for play_file().
        this.mpg = mpg;
        this.pulse = pulse;
        this.bufferSize = bufferSize;
        this.audio_position = 0;
        update_display();
    }

    /**
     * Play this.mpg until complete or interrupted.
     *
     * @return true if complete
     */
    private boolean play_file() {
        if this.mpg == null {
            return true;
        }
        var buffer = new byte[](this.bufferSize);
        while this.channel.getQueueSize() == 0 {
            var size = this.mpg.read(buffer);
            if size <= 0 {
                return true;
            }
            this.pulse.write(buffer, size);
            this.audio_position = this.audio_position + SAMPLE_MILLIS;
        }
        return false;
    }

    private void stop() {
        if this.pulse != null {
            this.pulse.free();
            this.pulse = null;
        }
        if this.mpg != null {
            this.mpg.close();
            this.mpg.delete();
            this.mpg = null;
        }
    }

    /**
     * This is called by the audio thread when it starts playing a new song, and
     * when it reaches the end of the playlist.
     */
    private void update_display() {
        Context.defaultContext().invoke(this);
    }

    /**
     * This is called by the GUI thread to start playing a specific song.
     */
    void play_songid(int playlistid, int songid) {
        this.channel.push(new PlayerCommand(){
            tag: PlayerCommand.PLAY, playlistid: playlistid, songid: songid
        });
    }

    /**
     * This is called by the GUI thread to start playing the previous or next song in
     * the playlist.
     */
    void play_next_song(int delta) {
        var playlist = this.player.playlists[this.playlistid];
        var songid = playlist == null ? 0 : playlist.get_next_id(this.songid, delta);
        this.channel.push(new PlayerCommand(){
            tag: PlayerCommand.PLAY, playlistid: this.playlistid, songid: songid
        });
    }

    /**
     * This is called by the GUI thread to pause and unpause the player.
     *
     * @return true if the player is now paused
     */
    boolean pause(boolean do_pause) {
        var tag = do_pause ? PlayerCommand.PAUSE : PlayerCommand.UNPAUSE;
        this.channel.push(new PlayerCommand(){tag: tag});
    }

    /**
     * Tell the player to jump forwards or backwards in the audio stream.
     */
    void do_audio_jump(float value) {
        // TODO this.target_position = value;
    }

    boolean is_playing() {
        return this.mpg != null;
    }

    /**
     * @return the length of the audio stream that has been played.
     */
    float get_audio_position_in_ms() {
        return this.audio_position;
    }

    void callback() {
        System.println("songid=" + this.songid);
        var song = this.player.database.song_list[this.songid];
        this.player.update_top_panel(song);
    }
}
